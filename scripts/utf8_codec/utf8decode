#!/bin/bash
#
# utf8decode - Given one or more underscore-encoded utf8 strings, return
#              the decoded UTF-8 version (one per line).
#

# Check a nibble starts with 0b >>10<< 00 0000
# Params:
#   val: hex value to check
__utf8decode_checknib() {
	local -i val=16#$1

	# if/else seems to be a tad faster than default fail
	if ((val >> 6 == 1 << 1)); then
		return 0
	else
		echo >&2 "Invalid encoding: 0x$1"
		return 1
	fi
}

# Decode utf8-encoded string, write decoded value to $ret.
# Params:
#   var: Value to decode
utf8decode() {
	local var=$1 res='' char chr i tmp

	for ((i=0; i<${#var}; i++)); do
		char=${var:$i:1}
		if [ "$char" = _ ]; then
			((++i))
			tmp=${var:$i:2}
			char="\\x$tmp"
			chr=16#$tmp
			((++i))
			if ((chr & 1 << 7)); then
				if ((chr & 1 << 6)); then
					((++i))
					tmp=${var:$i:2}
					char+="\\x$tmp"
					if ! __utf8decode_checknib "$tmp"; then
						echo >&2 "Invalid encoding"
						return 1
					fi
					((++i))
					if ((chr & 1 << 5)); then
						((++i))
						tmp=${var:$i:2}
						char+="\\x$tmp"
						if ! __utf8decode_checknib "$tmp"; then
							echo >&2 "Invalid encoding"
							return 1
						fi
						((++i))
						if ((chr & 1 << 4)); then
							((++i))
							tmp=${var:$i:2}
							char+="\\x$tmp"
							if ! __utf8decode_checknib "$tmp"; then
								echo >&2 "Invalid encoding"
								return 1
							fi
							((++i))
							if ((chr & 1 << 3)); then
								# Prefix cannot have more that 4 1's (0b1111 1000)
								echo >&2 "Invalid encoding"
								return 1
							fi
						fi
					fi
				else
					# Prefix cannot start with 0b1000 0000
					echo >&2 "Invalid encoding"
					return 1
				fi
			fi
			char=${char@E}
			# This is a lazy way of failing on the High Surrogates (U+D800 - DB7F),
			# High Private Use Surrogates (U+DB80 - U+DBFF) and Low Surrogates
			# (U+DC00 - U+DFFF). Even using the $'\Uxxxx' syntax bash seems to
			# encode it to hex and interpret it as whatever encoding that fits, like
			# iso-8859-1!!. Then we get >1 character...
			[ ${#char} -gt 1 ] && echo >&2 "Invalid encoding: $char" && return 1
		fi
		res+=$char
	done
	printf -v ret '%s' "$res"
}

# test
# set -- _5ffoo_e281bd_e284a2_e281bebar_f09f908d

for arg in "$@"; do
	utf8decode "$arg"
	printf '%s\n' "$ret"
done
