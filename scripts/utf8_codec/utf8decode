#!/bin/bash
#
# utf8decode - Given one or more underscore-encoded utf8 strings, return
#              the decoded UTF-8 version (one per line).
#

# Check parameter is valid hex
# Params:
#   $1: hex value to check
__utf8decode_isnib() {
	case $1 in
		[0-9A-Fa-f][0-9A-Fa-f])
			return 0
			;;
		*)
			echo >&2 "Invalid encoding: $1 is not hex"
			return 1
	esac
}

# Check a nibble starts with 0b >>10<< 00 0000
# Params:
#   val: hex value to check
__utf8decode_checknib() {
	__utf8decode_isnib "$1" || return
	local -i val=16#$1

	# if/else seems to be a tad faster than default fail
	if ((val >> 6 == 1 << 1)); then
		return 0
	else
		echo >&2 "Invalid encoding: 0x$1"
		return 1
	fi
}

# Decode utf8-encoded string, write decoded value to $ret.
# Params:
#   var: Value to decode
utf8decode() {
	local var=$1 res='' char tmp
	local -i chr i

	for ((i=0; i<${#var};)); do
		char=${var:i++:1}
		if [ "$char" = _ ]; then
			# Get first byte
			tmp=${var:i+=2,i-2:2}
			__utf8decode_isnib "$tmp" || return 1
			char="\\x$tmp"
			chr=16#$tmp
			if ((chr & 1 << 7)); then
				if ((chr & 1 << 6)); then
					tmp=${var:i+=2,i-2:2}
					if ! __utf8decode_checknib "$tmp"; then
						echo >&2 "Invalid encoding: 0x$tmp"
						return 1
					fi
					char+="\\x$tmp"
					if ((chr & 1 << 5)); then
						tmp=${var:i+=2,i-2:2}
						if ! __utf8decode_checknib "$tmp"; then
							echo >&2 "Invalid encoding: 0x$tmp"
							return 1
						fi
						char+="\\x$tmp"
						if ((chr & 1 << 4)); then
							tmp=${var:i+=2,i-2:2}
							if ! __utf8decode_checknib "$tmp"; then
								echo >&2 "Invalid encoding: 0x$tmp"
								return 1
							fi
							char+="\\x$tmp"
							if ((chr & 1 << 3)); then
								# Prefix cannot have more that 4 1's (0b1111 1000)
								echo >&2 "Invalid encoding: 0x$tmp"
								return 1
							fi
						fi
					fi
				else
					# Prefix cannot start with 0b1000 0000
					echo >&2 "Invalid encoding: 0x$tmp"
					return 1
				fi
			fi
			char=${char@E}
			# This is a lazy way of failing on the High Surrogates (U+D800 - DB7F),
			# High Private Use Surrogates (U+DB80 - U+DBFF) and Low Surrogates
			# (U+DC00 - U+DFFF). Even using the $'\Uxxxx' syntax bash seems to
			# encode it to hex and interpret it as whatever encoding that fits, like
			# iso-8859-1!!. Then we get >1 character...
			[ ${#char} -gt 1 ] && echo >&2 "Invalid encoding: $char" && return 1
		fi
		res+=$char
	done
	printf -v ret '%s' "$res"
}

# test
# set -- _5ffoo_e281bd_e284a2_e281bebar_f09f908d

for arg in "$@"; do
	utf8decode "$arg"
	printf '%s\n' "$ret"
done
